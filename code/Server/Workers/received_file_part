The " << k << "-th smallest element is " << *it_set << endl;
    }

    // Ordered Map
    auto it_map = om.find_by_order(k); // Returns an iterator to the k-th smallest key (0-based index).
    if (it_map != om.end()) {
        cout << "The " << k << "-th smallest key is " << it_map->first << " with value " << it_map->second << endl;
    }
    \end{lstlisting}
    \newpage
    \item \textbf{Finding the number of elements/keys less than a given value} \\
    To find the number of elements in the ordered\_set or keys in the ordered\_map that are less than a specific value, use \texttt{order\_of\_key}:
    \begin{lstlisting}
    int value = 6;
    
    // Ordered Set
    int count_set = os.order_of_key(value); // Number of elements strictly less than 6
    cout << "Number of elements less than " << value << " is " << count_set << endl;

    // Ordered Map
    int count_map = om.order_of_key(value); // Number of keys strictly less than 6
    cout << "Number of keys less than " << value << " is " << count_map << endl;
    \end{lstlisting}
\end{itemize}


\subsection{Trie from Policy-Based Data Structures (PBDS) in C++}

This section explains how to set up and use a \texttt{trie} from Policy-Based Data Structures (PBDS) in C++. The \texttt{trie} is useful for prefix-based searches, such as autocomplete or dictionary-like applications.

\subsubsection{Basic Setup and Operations}

To define and use a \texttt{trie}, include the necessary headers and set up the structure as follows:

\begin{lstlisting}
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/trie_policy.hpp>
using namespace __gnu_pbds;
using namespace std;

template <typename Key, typename Value = null_type>
using trie = trie<Key, Value, trie_string_access_traits<>, pat_trie_tag, trie_prefix_search_node_update>;
\end{lstlisting}

\textbf{Explanation:}
\begin{itemize}
    \item \textbf{Key}: The type of elements in the \texttt{trie} (e.g., \texttt{string}).
    \item \textbf{Value}: Optional; the type of values associated with keys (\texttt{null\_type} if not used).
    \item \textbf{trie\_string\_access\_traits}: Manages navigation through characters.
    \item \textbf{pat\_trie\_tag}: Optimizes the \texttt{trie} as a PATRICIA trie for space efficiency.
    \item \textbf{trie\_prefix\_search\_node\_update}: Supports efficient prefix-based searches.
\end{itemize}

\subsubsection{Basic Operations}

\textbf{Insertion}:
\begin{lstlisting}
trie<string> t;
t.insert("apple");
t.insert("banana");
\end{lstlisting}

\textbf{Deletion}:
\begin{lstlisting}
t.erase("banana");
\end{lstlisting}

\textbf{Prefix Search}:
\begin{lstlisting}
auto range = t.prefix_range("ap");
for (auto it = range.first; it != range.second; ++it)
    cout << *it << endl;
\end{lstlisting}

\textbf{Checking Existence}:
\begin{lstlisting}
if (t.find("apple") != t.end()) {
    cout << "'apple' exists" << endl;
}
\end{lstlisting}



\section{Graphs}

\subsection{Dijkstra}
\begin{lstlisting}
vec<pair<int, int>> G[MAX];
int dp[MAX];

void Dijkstra(int st){
    memset(dp, -1, sizeof(dp));
    priority_queue<pair<int, int>> pq;
    dp[st] = 0; pq.push({0, st});
    while(!pq.empty()){
        st = pq.top().second; int w = -pq.top().first; pq.pop(); 
        if(dp[st] != w) continue;
        for(auto &p : G[st]){
            int nxt = p.first; int w = p.second;
            if(dp[nxt] < 0 || dp[st] + w < dp[nxt])
                dp[nxt] = dp[st]+w, pq.emplace(-dp[nxt], nxt);
        }
    }
}
\end{lstlisting}
\newpage
\subsection{BFS}
\begin{lstlisting}
vec<int> G[MAX];

void BFS(int st){
    bitset<MAX> v; queue<int> bfs;
    bfs.push(st); v.set(st);
    while(!bfs.empty()){
        st = bfs.front(), bfs.pop();
        for(int &nx : G[st])
            if(!v.test(nx)) bfs.push(nx), v.set(nx);
    }
}
\end{lstlisting}

\subsection{Union Find}
\begin{lstlisting}
struct UnionFind{
    vec<int> uf;
    void init(int n){uf.assign(n, -1);}
    int Find(int i){return (uf[i]==-1)? i : uf[i] = Find(uf[i]);}
    bool Union(int i, int j){
        bool e = Find(i)==Find(j);
        if(!e) uf[Find(i)] = Find(j);
        return e;
    }
};
\end{lstlisting}


\subsection{Floyd Warshall}
\begin{lstlisting}
int G[MAX][MAX], n;

void FW(){
    for(int k = 0; k<n; ++k)
        for(int i = 0; i<n; ++i)
            if(G[i][k] < INF)
                for(int j = 0; j<n; ++j)
                    if(G[k][j] < INF) G[i][j] = min(G[i][j], G[i][k] + G[k][j]);
} 
\end{lstlisting}
\newpage
\subsection{Bellman Ford}
\begin{lstlisting}
int n, dp[MAX];
vec<pair<int, int>> G[MAX];

void BF(int st){
    
    memset(dp, INF, sizeof(dp)); dp[st] = 0;
    for(int k = 0; k<n; ++k)
        for(int i = 0; i<n; ++i)
            if(dp[i] != INF)
                for(auto &t : G[i])
                    dp[t.first] = min(dp[t.first], dp[i] + t.second);

    for(int i = 0; i<n; ++i)
        if(dp[i] != INF)
            for(auto &p : G[i])
                if(dp[p.first] > dp[i] + p.second) //negative cycle exists

}
\end{lstlisting}

\subsection{Khan}
\begin{lstlisting}
vec<int> G[MAX], topSort;
int in_deg[MAX], n;

bool Khan(){
    queue<int> Q;
    for(int i = 0; i<n; ++i) for(int &j : G[i]) ++in_deg[j];
    for(int i = 0; i<n; ++i) if(!in_deg[i]) Q.push(i);
    while(!Q.empty()){
        int c = Q.front(); Q.pop();
        topSort.push_back(c);
        for(int &j : G[c]) if(!(--in_deg[j])) Q.push(j);
    }return topSort.size() == n;
}
\end{lstlisting}

\newpage
\subsection{Kruskal}
\begin{lstlisting}
#define f first
#define s second

int uf[MAX];
vec<pair<int, pair<int, int>>> edgs; //(cost (u, v))

int Find(int i){return (uf[i]<0)? i : uf[i] = Find(uf[i]);}

bool Union(int i, int j){
    i = Find(i), j = Find(j);
    if(i == j) return 0;
    if(uf[i]>uf[j]) swap(i, j);
    uf[i]+=uf[j], uf[j]=i;
    return 1;
}

int kruskal(){
    sort(edgs.begin(), edgs.end());
    memset(uf, -1, sizeof(uf));
    int mst = 0;
    for(auto &p : edgs) if(Union(p.s.f, p.s.s)) mst += p.f;
    return mst;
}
\end{lstlisting}

\subsection{Prim}
\begin{lstlisting}
int n;
vec<pair<int, int>> G[MAX];
bitset<MAX> tkn;
priority_queue<pair<int, int>> pq;

void process(int v){
    tkn.set(v);
    for(auto &e : G[v]) if(!tkn.test(e.second)) pq.emplace(-e.first, e.second);
}

int prim(){
    tkn.reset(); process(0);
    int mst = 0;
    while(!pq.empty()){
        int c = pq.top().first, v = pq.top().second; pq.pop();
        if(!tkn.test(v)) mst -= c, process(v);
    }return mst;
}
\end{lstlisting}
\newpage

\subsection{Tarjan}
\begin{lstlisting}
int dfn[MAX], low[MAX], scc[MAX], idx, color, instk[MAX];
vec<int> G[MAX];
stack<int> st;

void Tarjan(int u){
    int v;
    dfn[u]=low[u]=++idx;
    st.push(u); instk[u]=1;
    for(int &v : G[u]){
        if(!dfn[v]){
            Tarjan(v);
            low[u]=min(low[u], low[v]);
        }else if(instk[v]) low[u]=min(low[u], dfn[v]);
    }
    /* Check SCC here
    if(dfn[u] == low[u]) {
        ++color;
        do {
            v = st.top(), instk[v]=0;
            st.pop();
            scc[v] = color;
        } while(v!=u);
    } */
}

int scc() {
    CLEAN(dfn); CLEAN(low); CLEAN(scc); idx=color=0;
    CLEAN(instk); while (!st.empty()) st.pop();
    for(int i=1; i<=n; ++i) if(!dfn[i]) Tarjan(i);
    return color;
}
\end{lstlisting}
\newpage
\subsection{Hierholzer}
\begin{lstlisting}
vec<int> G[MAX];
int n, in_deg[MAX], out_deg[MAX];
stack<int> path;

bool Eulerian(){
    int stV = 0, endV = 0;
    for(int i = 0; i<n; ++i){
        if(abs(in_deg[i]-out_deg[i]) > 1) return 0;
        stV+=(out_deg[i]-in_deg[i]==1);
        endV+=(in_deg[i]-out_deg[i]==1);
    }return !(stV+endV) || (stV+endV == 2);
}

int stV(){
    int stV = 0;
    for(int i = 0; i<n; ++i){
        if(out_deg[i]-in_deg[i]==1) return i;
        if(out_deg[i]) stV = i;
    }return stV;
}

void dfs(int i){
    while(out_deg[i]){
        int nx = G[i].back(); G[i].pop_back();
        --out_deg[i];
        dfs(nx)